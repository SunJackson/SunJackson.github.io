---
layout:     post
title:      The Mathematics Behind： Polynomial Curve Fitting (MATLAB)
subtitle:   转载自：https://www.data-blogger.com/2016/01/20/the-mathematics-behind-polynomial-curve-fitting/
date:       2016-01-20
author:     Kevin Jacobs
header-img: img/background0.jpg
catalog: true
tags:
    - error
    - mathematics
    - mathematical
    - datapoints
    - weights
---

In the series “The Mathematics Behind” I will explain mathematical concepts behind commonly used technologies. In this post, I will explain the mathematics behind polynomial curve fitting MATLAB.

First of all, what is polynomial curve fitting and where is it used for? Suppose we are trading on a stock market. The stock price is going up and down (see the figure) and we want to discover patterns in the price chances if any exists. Polynomial curve fitting tries to fit a model (here: a polynomial) on the given datapoints as good as possible.



## Curve Fitting MATLAB: The Hidden Function

I will tell you a little secret. The “hidden” curve was generated by using the following function: ![](https://s0.wp.com/latex.php?latex=y+%3D+%5Csin%282+%5Cpi+x%29+%2B+20&bg=ffffff&fg=000&s=0)
 and a little noise was added, but our algorithm will not know this secret. The goal of the algorithm is to find this hidden structure. And that is what curve fitting is all about.

## Model approximation

The model we will use to approximate this hidden function is a polynomial of degree 3. That means that the polynomial is of the form ![](https://s0.wp.com/latex.php?latex=w_0+%2B+w_1+x+%2B+w_2+x%5E2+%2B+w_3+x%5E3&bg=ffffff&fg=000&s=0)
. Notice that we have 4 degrees of freedom here since we can change the 4 weights in the model ![](https://s0.wp.com/latex.php?latex=w_0%2C+w_1%2C+w_2%2C+w_3&bg=ffffff&fg=000&s=0)
.

Notice that the polynomial can be expressed compactly: ![](https://s0.wp.com/latex.php?latex=y%28x%2C%5Ctextbf%7Bw%7D%29%3D%5Csum%5Climits_%7Bm%3D0%7D%5E3+w_m+x%5Em&bg=ffffff&fg=000&s=0)
. Our goal is to make this function as close as possible to the true datapoints. Suppose we have ![](https://s0.wp.com/latex.php?latex=N&bg=ffffff&fg=000&s=0)
 datapoints where the ![](https://s0.wp.com/latex.php?latex=n%5E%7Bth%7D&bg=ffffff&fg=000&s=0)
 datapoint is a pair ![](https://s0.wp.com/latex.php?latex=%28x_n%2C+t_n%29&bg=ffffff&fg=000&s=0)
. There are many ways to define an error metric. One possibility is the Mean Squared Error (MSE) which is defined as follows: ![](https://s0.wp.com/latex.php?latex=E%28%5Ctextbf%7Bw%7D%29+%3D+%5Cfrac%7B1%7D%7B2%7D+%5Csum%5Climits_%7Bn%3D1%7D%5EN+%28y%28x_n%2C%5Ctextbf%7Bw%7D%29-t_n%29%5E2&bg=ffffff&fg=000&s=0)
.

 

## Mathematical solution

In order to make the distance (the MSE) between the true datapoints and the polynomial as close as possible, we have to differentiate ![](https://s0.wp.com/latex.php?latex=E%28%5Ctextbf%7Bw%7D%29&bg=ffffff&fg=000&s=0)
. Note that ![](https://s0.wp.com/latex.php?latex=%5Cfrac%7B%5Cpartial+E%28%5Ctextbf%7Bw%7D%29%7D%7B%5Cpartial+w_i%7D+%3D+%5Csum%5Climits_%7Bn%3D1%7D%5EN+x%5Ei+%28w_0+%2B+w_1+x+%2B+w_2+x%5E2+%2B+w_3+x%5E3+-+t_n%29+%3D+%5Csum%5Climits_%7Bn%3D1%7D%5EN+%5Csum%5Climits_%7Bj%3D0%7D%5E3+w_j+x%5E%7Bi%2Bj%7D+-+w_i+t_n&bg=ffffff&fg=000&s=0)
. Now we can define some quantities, and we will do. These quantities seems weird at the first sight, but they will eventually solve the problem. Define: ![](https://s0.wp.com/latex.php?latex=A_%7Bij%7D+%3D+%5Csum%5Climits_%7Bn%3D1%7D%5EN+%28x_n%29%5E%7Bi%2Bj%7D&bg=ffffff&fg=000&s=0)
 and ![](https://s0.wp.com/latex.php?latex=T_i+%3D+%5Csum%5Climits_%7Bn%3D1%7D%5E%7BN%7D+%28x_n%29%5Ei+t_n&bg=ffffff&fg=000&s=0)
.

Now we have all the mathematical tools, we can solve this problem! First note that in order to minimize the MSE, we must have that all partial derivatives are zero: ![](https://s0.wp.com/latex.php?latex=%5Cfrac%7B%5Cpartial+E%28%5Ctextbf%7Bw%7D%29%7D%7B%5Cpartial+w_i%7D+%3D+0&bg=ffffff&fg=000&s=0)
. From this, we derive: ![](https://s0.wp.com/latex.php?latex=%5Csum%5Climits_%7Bn%3D1%7D%5EN+%5Csum%5Climits_%7Bj%3D0%7D%5E3+w_j+x%5E%7Bi%2Bj%7D+-+w_i+t_n+%3D+0&bg=ffffff&fg=000&s=0)
 and this is the same as ![](https://s0.wp.com/latex.php?latex=%5Csum%5Climits_%7Bj%3D0%7D%5E3+%5Csum%5Climits_%7Bn%3D1%7D%5EN+x_n%5E%7Bi%2Bj%7D+w_j+-+%5Csum%5Climits_%7Bn%3D1%7D%5EN+t_n+x%5Ei+%3D+0&bg=ffffff&fg=000&s=0)
 and here is where our weird quantities are needed, since this is equivalent to ![](https://s0.wp.com/latex.php?latex=%5Csum%5Climits_%7Bj%3D0%7D%5E3+A_%7Bij%7D+w_j+-+T_i+%3D+0&bg=ffffff&fg=000&s=0)
 and this is equivalent to ![](https://s0.wp.com/latex.php?latex=%5Csum%5Climits_%7Bj%3D0%7D%5E3+A_%7Bij%7Dw_j+%3D+T_i&bg=ffffff&fg=000&s=0)
. In matrix form, this is equivalent to ![](https://s0.wp.com/latex.php?latex=%5Ctextbf%7BA%7D+%5Ctextbf%7Bw%7D+%3D+%5Ctextbf%7BT%7D&bg=ffffff&fg=000&s=0)
 and this can be solved easily by left-muliplying by ![](https://s0.wp.com/latex.php?latex=%5Ctextbf%7BA%7D%5E%7B-1%7D&bg=ffffff&fg=000&s=0)
: ![](https://s0.wp.com/latex.php?latex=%5Ctextbf%7Bw%7D+%3D+%5Ctextbf%7BA%7D%5E%7B-1%7DT&bg=ffffff&fg=000&s=0)
.

## Algorithm implementation

By implementing these quantities in MatLab, the following weights can be found: ![](https://s0.wp.com/latex.php?latex=%5Ctextbf%7Bw%7D+%3D+%2819.85%2C+11.22%2C+-32.70%2C+21.72%29&bg=ffffff&fg=000&s=0)
. In other words, the “hidden” structure is: ![](https://s0.wp.com/latex.php?latex=y%28x%29+%3D+19.85+%2B+11.22+x+-+32.70+x%5E2+%2B+21.72+x%5E3&bg=ffffff&fg=000&s=0)
, which is shown in the following image (and the result is surprisingly close to the function which we want to approximate!).
![](https://www.data-blogger.com/wp-content/uploads/2016/01/polyfit-300x180.png)


Polynomial curve fitted to the data.

How can we bring the theory into practice? First, we need to calculate the weights, ![](https://s0.wp.com/latex.php?latex=%5Ctextbf%7Bw%7D&bg=ffffff&fg=000&s=0)
 and this can be done by using the following piece of MatLab code.

With the found weights, the complete found structure is encoded.

## Disadvantages

Are there disadvantages to the previously discussed method? Yes – The weights grow hard as the dimensionality (here: the degree of the polynomial) grows. This is solved by adding the size of the weight vector as additional error term and this technique is called shrinkage. Another problem is that the dimensionality is specified explicitely. There are other methods which do not have the dimensionality as parameter.

 

## Applications

What are the applications now we have found a fitting curve? Now we can for example calculate the expected minimum and maximum of the dataset. We can also find out where the function is steep (and where not) and many more questions can be answered. Although some mathematics were required to find the answer, the answer is generalizable and works for specific datasets. Good luck with your curve fitting MATLAB projects! And if you have any questions, feel free to contact me.

## Exercises

As an exercise for you: suppose we have two datapoints: ![](https://s0.wp.com/latex.php?latex=%280%2C+0%29&bg=ffffff&fg=000&s=0)
 and ![](https://s0.wp.com/latex.php?latex=%282%2C+1%29&bg=ffffff&fg=000&s=0)
. Find a polynomial of degree 1 (![](https://s0.wp.com/latex.php?latex=w_0+%2B+w_1+x&bg=ffffff&fg=000&s=0)
) which fits the data as good as possible. Implement it in your favorite programming language. (Hint: the answer is ![](https://s0.wp.com/latex.php?latex=0+%2B+%5Cfrac%7B1%7D%7B2%7D+x&bg=ffffff&fg=000&s=0)
). If this was too easy for you: try to generate ![](https://s0.wp.com/latex.php?latex=N&bg=ffffff&fg=000&s=0)
 datapoints by a function you know and add some noise to it. Find a polynomial of degree ![](https://s0.wp.com/latex.php?latex=m&bg=ffffff&fg=000&s=0)
 that fits your data.

## Bonus Material: Videos on Curve Fitting

If the concept is still not clear, please check out the following videos.





 
