---
layout:     post
catalog: true
title:      Python Pandas Tutorial： Analyzing Video Game Data
subtitle:      转载自：https://www.dataquest.io/blog/pandas-python-tutorial/
date:      2019-08-26
author:      Vik Paruchuri
tags:
    - reviewed
    - some_reviews
    - pandas
    - games
    - indexing
---








![](https://cdn.shortpixel.ai/client/q_glossy,ret_img/https://www.dataquest.io/wp-content/uploads/witcher.jpg)
![](https://cdn.shortpixel.ai/client/q_glossy,ret_img/https://www.dataquest.io/wp-content/uploads/witcher.jpg)



 Python’s pandas library is one of the things that makes Python a great programming language for data analysis. Pandas makes importing, analyzing, and visualizing data much easier. It builds on packages like NumPy and matplotlib to give you a single, convenient, place to do most of your data analysis and visualization work.
 


 In this Python data science tutorial, we’ll use Pandas to analyze video game reviews from IGN, a popular video game review site, using data scraped by Eric Grinstein. Which console is winning the “console wars” (in the sense of having better-reviewed games)? This data set will help us find out. 

As we analyze the video game reviews, we’ll learn about key pandas concepts like indexing. You can follow this up and learn more about Python and pandas in one of our many other Python tutorials, or by enrolling in our Python Pandas course. Many of our other data science courses also use pandas. 

Just as a note, this tutorial was written using Python 3.5 and built using Jupyter Notebook. You’re likely using a more updated versions of Python, pandas, and Jupyter, but your results should be essentially the same. 

## 
 Importing Data with Pandas


 The first step we’ll take is to read the data in. The data is stored as a comma-separated values, or csv, file, where each row is separated by a new line, and each column by a comma (`,`). Here are the first few rows of the `ign.csv` file:
 

```

,score_phrase,title,url,platform,score,genre,editors_choice,release_year,release_month,release_day
0,Amazing,LittleBigPlanet PS Vita,/games/littlebigplanet-vita/vita-98907,PlayStation Vita,9.0,Platformer,Y,2012,9,12
1,Amazing,LittleBigPlanet PS Vita -- Marvel Super Hero Edition,/games/littlebigplanet-ps-vita-marvel-super-hero-edition/vita-20027059,PlayStation Vita,9.0,Platformer,Y,2012,9,12
2,Great,Splice: Tree of Life,/games/splice/ipad-141070,iPad,8.5,Puzzle,N,2012,9,12
3,Great,NHL 13,/games/nhl-13/xbox-360-128182,Xbox 360,8.5,Sports,N,2012,9,11
```


 As you can see above, each row in the file represents a single game that was reviewed by IGN. The columns contain information about that game:
 


`score_phrase` — how IGN described the game in one word. This is linked to the score it received.
 

`title` — the name of the game.
 

`url` — the URL where you can see the full review.
 

`platform` — the platform the game was reviewed on (PC, PS4, etc).
 

`score` — the score for the game, from `1.0` to `10.0`.
 

`genre` — the genre of the game.
 

`editors_choice` — `N` if the game wasn’t an editor’s choice, `Y` if it was. This is tied to score.
 

`release_year` — the year the game was released.
 

`release_month` — the month the game was released.
 

`release_day` — the day the game was released.
 


 There’s also a leading column that contains row index values. We can safely ignore this column, but we’ll dive into what index values are later on.
 


 To work data effectively in Python and pandas, we’ll need to read the csv file into a Pandas DataFrame. A DataFrame is a way to represent and work with tabular data — data that’s in table form, like a spreadsheet. Tabular data has rows and columns, just like our csv file, but it’ll be easier for us to read and sort through if we can view it as a table.
 


 In order to read in the data, we’ll need to use the pandas.read_csv function. This function will take in a csv file and return a DataFrame. The below code will:
 


 Import the `pandas` library. We rename it to `pd` so it’s faster to type out. This is a standard convention in data analysis and data science, and you will often see pandas imported as `pd` in other people’s code.
 

 Read `ign.csv` into a DataFrame, and assign the result to a new variable called `reviews` so that we can use `reviews` to refer to our data.
 

```

import pandas as pd
reviews = pd.read_csv("ign.csv")

```


 Once we read in a DataFrame, it’s helpful to take a look at what we’ve got in a more visual way. Conveniently, Pandas gives us two methods that make it fast to print out the data a table. These functions are:
 


 DataFrame.head() — prints the first N rows of a DataFrame, where N is a number you pass as an argument to the function, i.e. `DataFrame.head(7)`. If you don’t pass any argument, the default is 5.
 

 DataFrame.tail() — prints the last N rows of a DataFrame. Again, the default is `5`.
 


 We’ll use the `head` method to see what’s in `reviews`:
 

```
reviews.head()
```

 Unnamed: 0 score_phrase title url platform score genre editors_choice release_year release_month release_day 
|------
| 0 | 0 | Amazing | LittleBigPlanet PS Vita | /games/littlebigplanet-vita/vita-98907 | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 1 | 1 | Amazing | LittleBigPlanet PS Vita — Marvel Super Hero E… | /games/littlebigplanet-ps-vita-marvel-super-he… | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 2 | 2 | Great | Splice: Tree of Life | /games/splice/ipad-141070 | iPad | 8.5 | Puzzle | N | 2012 | 9 | 12 |
| 3 | 3 | Great | NHL 13 | /games/nhl-13/xbox-360-128182 | Xbox 360 | 8.5 | Sports | N | 2012 | 9 | 11 |
| 4 | 4 | Great | NHL 13 | /games/nhl-13/ps3-128181 | PlayStation 3 | 8.5 | Sports | N | 2012 | 9 | 11 |


 We can also access the pandas.DataFrame.shape property to see row many rows and columns are in `reviews`:
 

```
reviews.shape
```

```
(18625, 11)
```


 As we can see, everything has been read in properly — we have `18,625` rows and `11` columns.
 


 One of the big advantages of using Pandas over a similar Python package like NumPy is that Pandas allows us to have columns with different data types. In our data set, `reviews`, we have columns that store float values like `score`, string values like `score_phrase`, and integers like `release_year`, so using NumPy here would be difficult, but Pandas and Python handle it well.
 


 Now that we’ve read the data in properly, let’s work on indexing `reviews` to get the rows and columns that we want.
 

## 
 Indexing DataFrames with Pandas


 Earlier, we used the `head` method to print the first `5` rows of `reviews`. We could accomplish the same thing using the pandas.DataFrame.iloc method. The `iloc` method allows us to retrieve rows and columns by position. In order to do that, we’ll need to specify the positions of the rows that we want, and the positions of the columns that we want as well. The below code will replicate the results of our `reviews.head()` by selecting rows zero to five, and all of the columns in our data set:
 

```
reviews.iloc[0:5,:]
```

 Unnamed: 0 score_phrase title url platform score genre editors_choice release_year release_month release_day 
|------
| 0 | 0 | Amazing | LittleBigPlanet PS Vita | /games/littlebigplanet-vita/vita-98907 | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 1 | 1 | Amazing | LittleBigPlanet PS Vita — Marvel Super Hero E… | /games/littlebigplanet-ps-vita-marvel-super-he… | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 2 | 2 | Great | Splice: Tree of Life | /games/splice/ipad-141070 | iPad | 8.5 | Puzzle | N | 2012 | 9 | 12 |
| 3 | 3 | Great | NHL 13 | /games/nhl-13/xbox-360-128182 | Xbox 360 | 8.5 | Sports | N | 2012 | 9 | 11 |
| 4 | 4 | Great | NHL 13 | /games/nhl-13/ps3-128181 | PlayStation 3 | 8.5 | Sports | N | 2012 | 9 | 11 |


 Let’s dig in a little deeper into our code: we specified that we wanted rows `0:5`. This means that we wanted the rows from position `0` up to, but not including, position `5`.
 


 The first row is considered to be in position `0`, so selecting rows `0:5` gives us the rows at positions `0`, `1`, `2`, `3`, and `4`. We wanted all of the columns, too, and we used a shortcut to select them. It works like this: if we leave off the first position value, like `:5`, it’s assumed we mean `0`. If we leave off the last position value, like `0:`, it’s assumed we mean the last row or column in the DataFrame. We wanted all of the columns, so we specified just a colon (`:`), without any positions. This gave us the columns from `0` to the last column. Here are some indexing examples, along with the results:
 


`reviews.iloc[:5,:]` — the first `5` rows, and all of the columns for those rows.
 

`reviews.iloc[:,:]` — the entire DataFrame.
 

`reviews.iloc[5:,5:]` — rows from position `5` onwards, and columns from position `5` onwards.
 

`reviews.iloc[:,0]` — the first column, and all of the rows for the column.
 

`reviews.iloc[9,:]` — the 10th row, and all of the columns for that row.
 


 Indexing by position is very similar to NumPy indexing. If you want to learn more, you can read our NumPy tutorial. Now that we know how to index by position, let’s remove the first column, which doesn’t have any useful information:
 

```

reviews = reviews.iloc[:,1:]
reviews.head()
```

 score_phrase title url platform score genre editors_choice release_year release_month release_day 
|------
| 0 | Amazing | LittleBigPlanet PS Vita | /games/littlebigplanet-vita/vita-98907 | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 1 | Amazing | LittleBigPlanet PS Vita — Marvel Super Hero E… | /games/littlebigplanet-ps-vita-marvel-super-he… | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 2 | Great | Splice: Tree of Life | /games/splice/ipad-141070 | iPad | 8.5 | Puzzle | N | 2012 | 9 | 12 |
| 3 | Great | NHL 13 | /games/nhl-13/xbox-360-128182 | Xbox 360 | 8.5 | Sports | N | 2012 | 9 | 11 |
| 4 | Great | NHL 13 | /games/nhl-13/ps3-128181 | PlayStation 3 | 8.5 | Sports | N | 2012 | 9 | 11 |

### 
 Indexing Using Labels in Python with Pandas


 Now that we know how to retrieve rows and columns by position, it’s worth looking into the other major way to work with DataFrames, which is to retrieve rows and columns by label. A major advantage of Pandas over NumPy is that each of the columns and rows has a label. Working with column positions is possible, but it can be hard to keep track of which number corresponds to which column.
 


 We can work with labels using the pandas.DataFrame.loc method, which allows us to index using labels instead of positions. We can display the first five rows of `reviews` using the `loc` method like this:
 

```
reviews.loc[0:5,:]
```

 score_phrase title url platform score genre editors_choice release_year release_month release_day 
|------
| 0 | Amazing | LittleBigPlanet PS Vita | /games/littlebigplanet-vita/vita-98907 | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 1 | Amazing | LittleBigPlanet PS Vita — Marvel Super Hero E… | /games/littlebigplanet-ps-vita-marvel-super-he… | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 2 | Great | Splice: Tree of Life | /games/splice/ipad-141070 | iPad | 8.5 | Puzzle | N | 2012 | 9 | 12 |
| 3 | Great | NHL 13 | /games/nhl-13/xbox-360-128182 | Xbox 360 | 8.5 | Sports | N | 2012 | 9 | 11 |
| 4 | Great | NHL 13 | /games/nhl-13/ps3-128181 | PlayStation 3 | 8.5 | Sports | N | 2012 | 9 | 11 |
| 5 | Good | Total War Battles: Shogun | /games/total-war-battles-shogun/mac-142565 | Macintosh | 7.0 | Strategy | N | 2012 | 9 | 11 |


 The above doesn’t actually look much different from `reviews.iloc[0:5,:]`. This is because while row labels can take on any values, our row labels match the positions exactly. You can see the row labels on the very left of the table above (they’re in bold). You can also see them by accessing the index property of a DataFrame. We’ll display the row indexes for `reviews`:
 

```
reviews.index
```

```
Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, ...], dtype='int64')
```


 Indexes don’t always have to match up with positions, though. In the below code cell, we’ll:
 


 Get row `10` to row `20` of `reviews`, and assign the result to `some_reviews`.
 

 Display the first `5` rows of `some_reviews`.
 

```
some_reviews = reviews.iloc[10:20,]
some_reviews.head()
```

 score_phrase title url platform score genre editors_choice release_year release_month release_day 
|------
| 10 | Good | Tekken Tag Tournament 2 | /games/tekken-tag-tournament-2/ps3-124584 | PlayStation 3 | 7.5 | Fighting | N | 2012 | 9 | 11 |
| 11 | Good | Tekken Tag Tournament 2 | /games/tekken-tag-tournament-2/xbox-360-124581 | Xbox 360 | 7.5 | Fighting | N | 2012 | 9 | 11 |
| 12 | Good | Wild Blood | /games/wild-blood/iphone-139363 | iPhone | 7.0 | NaN | N | 2012 | 9 | 10 |
| 13 | Amazing | Mark of the Ninja | /games/mark-of-the-ninja-135615/xbox-360-129276 | Xbox 360 | 9.0 | Action, Adventure | Y | 2012 | 9 | 7 |
| 14 | Amazing | Mark of the Ninja | /games/mark-of-the-ninja-135615/pc-143761 | PC | 9.0 | Action, Adventure | Y | 2012 | 9 | 7 |


 As you can see above, in `some_reviews`, the row indexes start at `10` and end at `20`. Thus, trying `loc` along with numbers lower than `10` or higher than `20` will result in an error:
 

```
some_reviews.loc[9:21,:]
```

```

---------------------------------------------------------------------------
KeyError Traceback (most recent call last)
<ipython -input-76-5378b774c9a7> in <module>()
----> 1 some_reviews.loc[9:21,:]
/Users/vik/python_envs/dsserver/lib/python3.4/site-packages/pandas/core/indexing.py in __getitem__(self, key)
1198 def __getitem__(self, key):
1199 if type(key) is tuple:
-> 1200 return self._getitem_tuple(key)
1201 else:
1202 return self._getitem_axis(key, axis=0)
/Users/vik/python_envs/dsserver/lib/python3.4/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup)
702
703 # no multi-index, so validate all of the indexers
--> 704 self._has_valid_tuple(tup)
705
706 # ugly hack for GH #836
/Users/vik/python_envs/dsserver/lib/python3.4/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, key)
129 if i >= self.obj.ndim:
130 raise IndexingError('Too many indexers')
--> 131 if not self._has_valid_type(k, i):
132 raise ValueError("Location based indexing can only have [%s] "
133 "types" % self._valid_types)
/Users/vik/python_envs/dsserver/lib/python3.4/site-packages/pandas/core/indexing.py in _has_valid_type(self, key, axis)
1258 raise KeyError(
1259 "start bound [%s] is not the [%s]" %
-> 1260 (key.start, self.obj._get_axis_name(axis))
1261 )
1262 if key.stop is not None:
KeyError: 'start bound [9] is not the [index]'
</module></ipython>
```


 As we mentioned earlier, column labels can make life much easier when you’re working with data. We can specify column labels in the `loc` method to retrieve columns by label instead of by position.
 

```
reviews.loc
[:5,"score"]
```

```
0 9.0
1 9.0
2 8.5
3 8.5
4 8.5
5 7.0
Name: score, dtype: float64
```


 We can also specify more than one column at a time by passing in a list:
 

```
reviews.loc[:5,["score", "release_year"]]
```

 score release_year 
|------
| 0 | 9.0 | 2012 |
| 1 | 9.0 | 2012 |
| 2 | 8.5 | 2012 |
| 3 | 8.5 | 2012 |
| 4 | 8.5 | 2012 |
| 5 | 7.0 | 2012 |

## 
 Pandas Series Objects


 We can retrieve an individual column in Pandas a few different ways. So far, we’ve seen two types of syntax for this:
 


`reviews.iloc[:,1]` — will retrieve the second column.
 

`reviews.loc[:,"score_phrase"]` — will also retrieve the second column.
 


 There’s a third, even easier, way to retrieve a whole column. We can just specify the column name in square brackets, like with a dictionary:
 

```
reviews["score"]
```

```
0 9.0
1 9.0
2 8.5
3 8.5
4 8.5
5 7.0
6 3.0
7 9.0
8 3.0
9 7.0
10 7.5
11 7.5
12 7.0
13 9.0
14 9.0
...
18610 6.0
18611 5.8
18612 7.8
18613 8.0
18614 9.2
18615 9.2
18616 7.5
18617 8.4
18618 9.1
18619 7.9
18620 7.6
18621 9.0
18622 5.8
18623 10.0
18624 10.0
Name: score, Length: 18625, dtype: float64
```


 We can also use lists of columns with this method:
 

```
reviews[["score", "release_year"]]
```

 score release_year 
|------
| 0 | 9.0 | 2012 |
| 1 | 9.0 | 2012 |
| 2 | 8.5 | 2012 |
| 3 | 8.5 | 2012 |
| 4 | 8.5 | 2012 |
| 5 | 7.0 | 2012 |
| 6 | 3.0 | 2012 |
| 7 | 9.0 | 2012 |
| 8 | 3.0 | 2012 |
| 9 | 7.0 | 2012 |
| 10 | 7.5 | 2012 |
| 11 | 7.5 | 2012 |
| 12 | 7.0 | 2012 |
| 13 | 9.0 | 2012 |
| 14 | 9.0 | 2012 |
| 15 | 6.5 | 2012 |
| 16 | 6.5 | 2012 |
| 17 | 8.0 | 2012 |
| 18 | 5.5 | 2012 |
| 19 | 7.0 | 2012 |
| 20 | 7.0 | 2012 |
| 21 | 7.5 | 2012 |
| 22 | 7.5 | 2012 |
| 23 | 7.5 | 2012 |
| 24 | 9.0 | 2012 |
| 25 | 7.0 | 2012 |
| 26 | 9.0 | 2012 |
| 27 | 7.5 | 2012 |
| 28 | 8.0 | 2012 |
| 29 | 6.5 | 2012 |
| … | … | … |
| 18595 | 4.4 | 2016 |
| 18596 | 6.5 | 2016 |
| 18597 | 4.9 | 2016 |
| 18598 | 6.8 | 2016 |
| 18599 | 7.0 | 2016 |
| 18600 | 7.4 | 2016 |
| 18601 | 7.4 | 2016 |
| 18602 | 7.4 | 2016 |
| 18603 | 7.8 | 2016 |
| 18604 | 8.6 | 2016 |
| 18605 | 6.0 | 2016 |
| 18606 | 6.4 | 2016 |
| 18607 | 7.0 | 2016 |
| 18608 | 5.4 | 2016 |
| 18609 | 8.0 | 2016 |
| 18610 | 6.0 | 2016 |
| 18611 | 5.8 | 2016 |
| 18612 | 7.8 | 2016 |
| 18613 | 8.0 | 2016 |
| 18614 | 9.2 | 2016 |
| 18615 | 9.2 | 2016 |
| 18616 | 7.5 | 2016 |
| 18617 | 8.4 | 2016 |
| 18618 | 9.1 | 2016 |
| 18619 | 7.9 | 2016 |
| 18620 | 7.6 | 2016 |
| 18621 | 9.0 | 2016 |
| 18622 | 5.8 | 2016 |
| 18623 | 10.0 | 2016 |
| 18624 | 10.0 | 2016 |


 18625 rows × 2 columns
 


 When we retrieve a single column, we’re actually retrieving a Pandas Series object. A DataFrame stores tabular data, but a Series stores a single column or row of data.
 


 We can verify that a single column is a Series:
 

```
type(reviews["score"])
```

```
pandas.core.series.Series
```


 We can create a Series manually to better understand how it works. To create a Series, we pass a list or NumPy array into the Series object when we instantiate it:
 

```
s1 = pd.Series([1,2])
s1
```

```

0 1
1 2
dtype: int64
```


 A Series can contain any type of data, including mixed types. Here, we create a Series that contains string objects:
 

```
s2 = pd.Series(["Boris Yeltsin", "Mikhail Gorbachev"])
s2
```

```

0 Boris Yeltsin
1 Mikhail Gorbachev
dtype: object
```

## 
 Creating A DataFrame in Pandas


 We can create a DataFrame by passing multiple Series into the DataFrame class. Here, we pass in the two Series objects we just created,
 


`s1` as the first row, and `s2` as the second row:
 

```
pd.DataFrame([s1,s2])
```

 0 1 
|------
| 0 | 1 | 2 |
| 1 | Boris Yeltsin | Mikhail Gorbachev |


 We can also accomplish the same thing with a list of lists. Each inner list is treated as a row in the resulting DataFrame:
 

```
pd.DataFrame(
 [
 [1,2],
 ["Boris Yeltsin", "Mikhail Gorbachev"]
 ]
)

```

 0 1 
|------
| 0 | 1 | 2 |
| 1 | Boris Yeltsin | Mikhail Gorbachev |


 We can specify the column labels when we create a DataFrame:
 

```

pd.DataFrame(
 [
 [1,2],
 ["Boris Yeltsin", "Mikhail Gorbachev"]
 ],
 columns=["column1", "column2"]
)
```

 column1 column2 
|------
| 0 | 1 | 2 |
| 1 | Boris Yeltsin | Mikhail Gorbachev |


 As well as the row labels (the index):
 

```
frame = pd.DataFrame(
 [
 [1,2],
 ["Boris Yeltsin", "Mikhail Gorbachev"]
 ],
 index=["row1", "row2"],
 columns=["column1", "column2"]
)
frame
```

 column1 column2 
|------
| row1 | 1 | 2 |
| row2 | Boris Yeltsin | Mikhail Gorbachev |


 Note also that the indentation and separate lines are not required. We’ve written the code this way to make it a bit easier to parse, but you’ll often encounter it all written as one line. For example, the following code will produce the exact same results as what we see in the table above this paragraph: 

```

frame = pd.DataFrame([[1,2],["Boris Yeltsin", "Mikhail Gorbachev"]],index=["row1", "row2"],columns=["column1", "column2"])

frame
```

 Anyway, once we’ve added labels, we’re then able index the DataFrame using them:
 

```
frame.loc["row1":"row2", "column1"]
```

```

row1 1
row2 Boris Yeltsin
Name: column1, dtype: object
```


 We can skip specifying the `columns` keyword argument if we pass a dictionary into the `DataFrame` constructor. This will automatically set up column names:
 

```

frame = pd.DataFrame(
 {
 "column1": [1, "Boris Yeltsin"],
 "column2": [2, "Mikhail Gorbachev"]
 }
)
frame
```

 column1 column2 
|------
| 0 | 1 | 2 |
| 1 | Boris Yeltsin | Mikhail Gorbachev |

## 
 Pandas DataFrame Methods


 As we mentioned earlier, each column in a pandas DataFrame is a Series object:
 

```
type(reviews["title"])
```

```
pandas.core.series.Series
```


 We can call most of the same methods on a Series object that we can on a DataFrame, including `head`:
 

```
reviews["title"].head()
```

```

0 LittleBigPlanet PS Vita
1 LittleBigPlanet PS Vita -- Marvel Super Hero E...
2 Splice: Tree of Life
3 NHL 13
4 NHL 13
Name: title, dtype: object
```


 Pandas Series and DataFrames also have other methods that make calculations simpler. For example, we can use the pandas.Series.mean method to find the mean of a Series:
 

```
reviews["score"].mean()
```

```
6.950459060402685
```


 We can also call the similar pandas.DataFrame.mean method, which will find the mean of each numerical column in a DataFrame by default:
 

```
reviews.mean()
```

```

score 6.950459
release_year 2006.515329
release_month 7.138470
release_day 15.603866
dtype: float64
```


 We can modify the `axis` keyword argument to `mean` in order to compute the mean of each row or of each column. By default, `axis` is equal to `0`, and will compute the mean of each column. We can also set it to `1` to compute the mean of each row. Note that this will only compute the mean of the numerical values in each row:
 

```
reviews.mean(axis=1)
```

```
0 510.500
1 510.500
2 510.375
3 510.125
4 510.125
5 509.750
6 508.750
7 510.250
8 508.750
9 509.750
10 509.875
11 509.875
12 509.500
13 509.250
14 509.250
...
18610 510.250
18611 508.700
18612 509.200
18613 508.000
18614 515.050
18615 515.050
18616 508.375
18617 508.600
18618 515.025
18619 514.725
18620 514.650
18621 515.000
18622 513.950
18623 515.000
18624 515.000
Length: 18625, dtype: float64
```


 There are quite a few methods on Series and DataFrames that behave like `mean`. Here are some handy ones:
 


 For example, we can use the `corr` method to see if any columns correlate with `score`. This would tell us if games released more recently have been getting higher reviews (`release_year`), or if games released towards the end of the year score better (`release_month`):
 

```
reviews.corr()
```

 score release_year release_month release_day 
|------
| score | 1.000000 | 0.062716 | 0.007632 | 0.020079 |
| release_year | 0.062716 | 1.000000 | -0.115515 | 0.016867 |
| release_month | 0.007632 | -0.115515 | 1.000000 | -0.067964 |
| release_day | 0.020079 | 0.016867 | -0.067964 | 1.000000 |


 As we can see above, none of our numeric columns correlate with `score`, so we know that release timing doesn’t linearly relate to review score.
 

### 
 DataFrame Math with Pandas


 We can also perform math operations on Series or DataFrame objects in Python with pandas. For example, we can divide every value in the `score` column by `2` to switch the scale from `0`–`10` to `0`–`5`:
 

```
reviews["score"] / 2
```

```
0 4.50
1 4.50
2 4.25
3 4.25
4 4.25
5 3.50
6 1.50
7 4.50
8 1.50
9 3.50
10 3.75
11 3.75
12 3.50
13 4.50
14 4.50
...
18610 3.00
18611 2.90
18612 3.90
18613 4.00
18614 4.60
18615 4.60
18616 3.75
18617 4.20
18618 4.55
18619 3.95
18620 3.80
18621 4.50
18622 2.90
18623 5.00
18624 5.00
Name: score, Length: 18625, dtype: float64
```


 All the common mathematical operators that work in Python, like `+`, `-`, `*`, `/`, and `^` will work in pandas on Series or DataFrames, and will apply to each element in a DataFrame or a Series.
 

## 
 Boolean Indexing in Pandas


 Now that we’ve gotten a bit of the pandas basics down, let’s move towards the meat of our analysis. We saw earlier that the mean of all the values in the `score` column of `reviews` is around `7`. What if we wanted to find all the games that got an above-average score?
 


 We could start by doing a comparison. The comparison compares each value in a Series to a specified value, then generate a Series full of Boolean values indicating the status of the comparison. For example, we can see which of the rows have a `score` value higher than `7`:
 

```

score_filter = reviews["score"] > 7
score_filter
```

```

0 True
1 True
2 True
3 True
4 True
5 False
6 False
7 True
8 False
9 False
10 True
11 True
12 False
13 True
14 True...
18610 False
18611 False
18612 True
18613 True
18614 True
18615 True
18616 True
18617 True
18618 True
18619 True
18620 True
18621 True
18622 False
18623 True
18624 True
Name: score, Length: 18625, dtype: bool
```


 Once we have a Boolean Series, we can use it to select only rows in a DataFrame where the Series contains the value `True`. So, we could only select rows in `reviews` where `score` is greater than `7`:
 

```

filtered_reviews = reviews[score_filter]
filtered_reviews.head()
```

 score_phrase title url platform score genre editors_choice release_year release_month release_day 
|------
| 0 | Amazing | LittleBigPlanet PS Vita | /games/littlebigplanet-vita/vita-98907 | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 1 | Amazing | LittleBigPlanet PS Vita — Marvel Super Hero E… | /games/littlebigplanet-ps-vita-marvel-super-he… | PlayStation Vita | 9.0 | Platformer | Y | 2012 | 9 | 12 |
| 2 | Great | Splice: Tree of Life | /games/splice/ipad-141070 | iPad | 8.5 | Puzzle | N | 2012 | 9 | 12 |
| 3 | Great | NHL 13 | /games/nhl-13/xbox-360-128182 | Xbox 360 | 8.5 | Sports | N | 2012 | 9 | 11 |
| 4 | Great | NHL 13 | /games/nhl-13/ps3-128181 | PlayStation 3 | 8.5 | Sports | N | 2012 | 9 | 11 |


 It’s possible to use multiple conditions for filtering. Let’s say we want to find games released for the `Xbox One` that have a score of more than `7`. In the below code, we:
 


 Setup a filter with two conditions: 

 Check if `score` is greater than `7`.
 

 Check if `platform` equals `Xbox One`


```

xbox_one_filter = (reviews["score"] > 7) & (reviews["platform"] == "Xbox One")
filtered_reviews = reviews[xbox_one_filter]
filtered_reviews.head()

```

 score_phrase title url platform score genre editors_choice release_year release_month release_day 
|------
| 17137 | Amazing | Gone Home | /games/gone-home/xbox-one-20014361 | Xbox One | 9.5 | Simulation | Y | 2013 | 8 | 15 |
| 17197 | Amazing | Rayman Legends | /games/rayman-legends/xbox-one-20008449 | Xbox One | 9.5 | Platformer | Y | 2013 | 8 | 26 |
| 17295 | Amazing | LEGO Marvel Super Heroes | /games/lego-marvel-super-heroes/xbox-one-20000826 | Xbox One | 9.0 | Action | Y | 2013 | 10 | 22 |
| 17313 | Great | Dead Rising 3 | /games/dead-rising-3/xbox-one-124306 | Xbox One | 8.3 | Action | N | 2013 | 11 | 18 |
| 17317 | Great | Killer Instinct | /games/killer-instinct-2013/xbox-one-20000538 | Xbox One | 8.4 | Fighting | N | 2013 | 11 | 18 |


 When filtering with multiple conditions, it’s important to put each condition in parentheses, and separate them with a single ampersand (`&`).
 

## 
 Pandas Plotting


 Now that we know how to filter, we can create plots to observe the review distribution for the `Xbox One` vs the review distribution for the `PlayStation 4`. This will help us figure out which console has better games.
 


 We can do this via a histogram, which will plot the frequencies for different score ranges. We can make a histogram for each console using the pandas.DataFrame.plot method. This method utilizes matplotlib, the popular Python plotting library, under the hood, to generate good-looking plots.
 


 The `plot` method defaults to drawing a line graph. We’ll need to pass in the keyword argument `kind="hist"` to draw a histogram instead. In the below code, we:
 


 Call `%matplotlib inline` to set up plotting inside a Jupyter notebook.
 

 Filter `reviews` to only have data about the `Xbox One`.
 

 Plot the `score` column.
 

```


reviews[reviews["platform"] == "Xbox One"]["score"].plot(kind="hist")
```

```
<matplotlib.axes._subplots.AxesSubplot at 0x10c9c5438>
```
![](data:image/png;base64,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)



 We can also do the same for the `PS4`:
 

```
reviews[reviews["platform"] == "PlayStation 4"]["score"].plot(kind="hist")
```

```
<matplotlib.axes._subplots.AxesSubplot at 0x10c9e0e80>
```
![](data:image/png;base64,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)



 It appears from our histogram that the `PlayStation 4` has many more highly rated games than the `Xbox One`.
 


 Obviously, this is just the tip of the iceberg when it comes to the potential directions we could take analyzing this data set, but we’re already off to a great start: we’ve imported a data set using Python and pandas, learned to select the data points we want using a variety of different indexing methods, and done some quick exploratory data analysis to answer the question we started with.
 

## 
 Free Pandas Cheat Sheet


 If you’re interested in learning more about pandas, check out our interactive course on NumPy and pandas. You can register and do the first missions for free. You also might like to take your pandas skills to the next level with our free pandas cheat sheet!


## 
 Further Reading


 Hopefully,, this python data science tutorial, helped teach you how to read, explore, analyze, and visualize data using Pandas and Python. In the next post, we cover grouping data and doing more advanced computations. You can find it here. If you want to read more about Pandas, check out these resources:
 

*This article was last updated in August 2019*.













