---
layout:     post
title:      How-to： Use Cascading Pattern with R and CDH
subtitle:   转载自：http://blog.cloudera.com/blog/2013/11/how-to-use-cascading-pattern-with-r-and-cdh/
date:       2013-11-08
author:     Justin Kestelyn
header-img: img/background1.jpg
catalog: true
tags:
    - models
    - modeling
    - cascading
    - predictive
    - predicted
---

*Our thanks to Concurrent Inc. for the how-to below about using Cascading Pattern with CDH. Cloudera recently tested CDH 4.4 with the Cascading Compatibility Test Suite [verifying compatibility](http://www.cascading.org/support/compatibility) with Cascading 2.2.*

[Cascading Pattern](https://github.com/cascading/pattern) is a machine-learning project within the [Cascading](http://cascading.org/.) development framework used to build enterprise data workflows. Cascading provides an abstraction layer on top of Apache Hadoop and other computing topologies that allows enterprises to leverage existing skills and resources to build data processing applications on Hadoop, without the need for specialized Hadoop skills.

Pattern, in particular, leverages an industry standard called Predictive Model Markup Language (PMML), which allows data scientists to leverage their favorite statistical and analytics tools (such as R, SAS, Oracle, and so on) to export predictive models and quickly run them on data sets stored in Hadoop. Pattern’s benefits include reduced development costs, time savings, and reduced licensing issues at scale – all while leveraging Hadoop clusters, core competencies of analytics staff, and existing intellectual property in the predictive models.

By using Cascading Pattern, predictive modeling can now be exported as PMML from a variety of analytics frameworks, then run on Hadoop at scale. This approach saves licensing costs, allows for applications to scale-out, and directly integrates predictive modeling — expressed as Cascading apps — within other business logic.

In this how-to, you will learn how to create a simple example model using Cascading, R, and CDH.

## Step 1: Set Up Your Environment

In this section, we will go through the steps needed to set up your environment.


To set up Java for your environment, download [Java](http://www.java.com/getjava) and follow the installation instructions. Version 1.6.x was used to create the examples used here.


Get the JDK, not the JRE.


Install according to vendor instructions.


Be sure to set the JAVA_HOME environment variable correctly.


To set up Gradle for your environment, download [Gradle](http://www.gradle.org/downloads) and follow the installation instructions. Version 1.4 and later is required for some examples in this tutorial.


Install according to vendor instructions.


Be sure to set the GRADLE_HOME environment variable correctly.


Install [CDH 4.4](https://www.cloudera.com/content/support/en/downloads/download-components.html) in standalone mode.

Set up R and RStudio for your environment by visiting:

## Step 2: Get the Source Code

Navigate to the [Pattern Github project](https://github.com/Cascading/pattern) and in the bottom right corner of the screen, click **Download ZIP**to download a ZIP compressed archive of the source code. When complete, unzip and move the directory “pattern” to a location on your filesystem where you have space available to work.

## Step 3: Create the Model

Navigate to the pattern directory, and then into its pattern-examples subdirectory. There is an example R script in examples/r/rf_pmml.R that creates a Random Forest model. This is representative of a predictive model for an anti-fraud classifier used in e-commerce apps.







|12345678910111213141516171819|## train a RandomForest modelf <- as.formula("as.factor(label) ~ .")fit <- randomForest(f, data_train, ntree=50) ## test the model on the holdout test setprint(fit$importance)print(fit) predicted <- predict(fit, data)data$predicted <- predictedconfuse <- table(pred = predicted, true = data[,1])print(confuse) ## export predicted labels to TSVwrite.table(data, file=paste(dat_folder, "sample.tsv", sep="/"),  quote=FALSE, sep="\t", row.names=FALSE) ## export RF model to PMMLsaveXML(pmml(fit), file=paste(dat_folder, "sample.rf.xml", sep="/"))|

2

4

6

8

10

12

14

16

18

f <- as.formula("as.factor(label) ~ .")

 

print(fit$importance)

 

data$predicted <- predicted

print(confuse)

## export predicted labels to TSV

  quote=FALSE, sep="\t", row.names=FALSE)

## export RF model to PMML


 

Load the “rf_pmml.R” script into RStudio using the **File** menu and **Open File..**option.

Click the **Source** button in the upper middle section of the screen. That will execute the R script and create the predictive model.

![](http://blog.cloudera.com/wp-content/uploads/2013/11/cascading3.png)


The last line saves the predictive model into a file called sample.rf.xml as PMML. PMML is XML-based and thus not optimal for humans to read, but it is efficient for machines to parse:







|123456789101112131415161718192021222324252627282930313233343536373839|<?xml version="1.0"?><PMML version="4.0" xmlns="http://www.dmg.org/PMML-4_0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.dmg.org/PMML-4_0 http://www.dmg.org/v4-0/pmml-4-0.xsd"> <Header copyright="Copyright (c)2012 Concurrent, Inc."  description="Random Forest Tree Model">  <Extension name="user" value="ceteri" extender="Rattle/PMML"/>  <Application name="Rattle/PMML" version="1.2.30"/>  <Timestamp>2012-10-22 19:39:28</Timestamp> </Header> <DataDictionary numberOfFields="4">  <DataField name="label" optype="categorical" dataType="string">   <Value value="0"/>   <Value value="1"/>  </DataField>  <DataField name="var0" optype="continuous" dataType="double"/>  <DataField name="var1" optype="continuous" dataType="double"/>  <DataField name="var2" optype="continuous" dataType="double"/> </DataDictionary> <MiningModel modelName="randomForest_Model" functionName="classification">  <MiningSchema>   <MiningField name="label" usageType="predicted"/>   <MiningField name="var0" usageType="active"/>   <MiningField name="var1" usageType="active"/>   <MiningField name="var2" usageType="active"/>  </MiningSchema>  <Segmentation multipleModelMethod="majorityVote">   <Segment id="1">    <True/>    <TreeModel modelName="randomForest_Model" functionName="classification"     algorithmName="randomForest" splitCharacteristic="binarySplit">     <MiningSchema>      <MiningField name="label" usageType="predicted"/>      <MiningField name="var0" usageType="active"/>      <MiningField name="var1" usageType="active"/>      <MiningField name="var2" usageType="active"/>     </MiningSchema>...|

2

4

6

8

10

12

14

16

18

20

22

24

26

28

30

32

34

36

38

<PMML version="4.0" xmlns="http://www.dmg.org/PMML-4_0"

 xsi:schemaLocation="http://www.dmg.org/PMML-4_0

 <Header copyright="Copyright (c)2012 Concurrent, Inc."

  <Extension name="user" value="ceteri" extender="Rattle/PMML"/>

  <Timestamp>2012-10-22 19:39:28</Timestamp>

 <DataDictionary numberOfFields="4">

   <Value value="0"/>

  </DataField>

  <DataField name="var1" optype="continuous" dataType="double"/>

 </DataDictionary>

  <MiningSchema>

   <MiningField name="var0" usageType="active"/>

   <MiningField name="var2" usageType="active"/>

  <Segmentation multipleModelMethod="majorityVote">

    <True/>

     algorithmName="randomForest" splitCharacteristic="binarySplit">

      <MiningField name="label" usageType="predicted"/>

      <MiningField name="var1" usageType="active"/>

     </MiningSchema>


 

Cascading Pattern supports additional models, as well as ensembles, of the following models:

- General Regression

- Regression

- Clustering

- Tree

- Mining


## Step 4: Build Cascading

Now that we have a model created and exported as PMML, let’s work on running it at scale atop CDH.

In the pattern-examples directory, execute the following Bash shell commands:







||


 

That line invokes Gradle to run the build script build.gradle, and compile the Cascading Pattern example app. After that compiles, look for the built app as a JAR file in the build/libs subdirectory:







||> ls -lts build/libs/pattern-examples-*.jar|


 

Now we’re ready to run this Cascading Pattern example app on CDH. First, we make sure to delete the output results (required by Hadoop). Then we run Hadoop: we specify the JAR file for the app, the PMML file using a `--pmml`command line option, along with sample input data data/sample.tsv and the location of the output results:







||> rm -rf out> hadoop jar build/libs/pattern-examples-*.jar\ data/sample.tsv out/classify --pmml data/sample.rf.xml|

> hadoop jar build/libs/pattern-examples-*.jar\ data/sample.tsv out/classify --pmml data/sample.rf.xml


 

After that runs, check the out/classify subdirectory. Look at the results of running the PMML model, which will be in the part-* partition files:







||> less out/classify/part-*|


 

Let’s take a look at what we just built and ran. The source code for this example is located in the src/main/java/cascading/pattern/Main.java file:







|1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950|public class Main  {  /** @param args  */  public static void main( String[] args ) throws RuntimeException    {    String inputPath = args[ 0 ];    String classifyPath = args[ 1 ];     // set up the config properties    Properties properties = new Properties();    AppProps.setApplicationJarClass( properties, Main.class );     HadoopFlowConnector flowConnector = new HadoopFlowConnector( properties );     // create source and sink taps    Tap inputTap = new Hfs( new TextDelimited( true, "\t" ), inputPath );    Tap classifyTap = new Hfs( new TextDelimited( true, "\t" ), classifyPath );     // handle command line options    OptionParser optParser = new OptionParser();    optParser.accepts( "pmml" ).withRequiredArg();     OptionSet options = optParser.parse( args );     // connect the taps, pipes, etc., into a flow    FlowDef flowDef = FlowDef.flowDef()      .setName( "classify" )      .addSource( "input", inputTap )      .addSink( "classify", classifyTap );     // build a Cascading assembly from the PMML description    if( options.hasArgument( "pmml" ) )      {      String pmmlPath = (String) options.valuesOf( "pmml" ).get( 0 );       PMMLPlanner pmmlPlanner = new PMMLPlanner()        .setPMMLInput( new File( pmmlPath ) )        .retainOnlyActiveIncomingFields()        .setDefaultPredictedField( new Fields( "predict", Double.class ) );      // default value if missing from the model       flowDef.addAssemblyPlanner( pmmlPlanner );      }     // write a DOT file and run the flow    Flow classifyFlow = flowConnector.connect( flowDef );    classifyFlow.writeDOT( "dot/classify.dot" );    classifyFlow.complete();    }  }|

2

4

6

8

10

12

14

16

18

20

22

24

26

28

30

32

34

36

38

40

42

44

46

48

50

  {

  public static void main( String[] args ) throws RuntimeException

    String inputPath = args[ 0 ];

 

    Properties properties = new Properties();

 

 

    Tap inputTap = new Hfs( new TextDelimited( true, "\t" ), inputPath );

 

    OptionParser optParser = new OptionParser();

 

 

    FlowDef flowDef = FlowDef.flowDef()

      .addSource( "input", inputTap )

 

    if( options.hasArgument( "pmml" ) )

      String pmmlPath = (String) options.valuesOf( "pmml" ).get( 0 );

      PMMLPlanner pmmlPlanner = new PMMLPlanner()

        .retainOnlyActiveIncomingFields()

      // default value if missing from the model

      flowDef.addAssemblyPlanner( pmmlPlanner );

 

    Flow classifyFlow = flowConnector.connect( flowDef );

    classifyFlow.complete();

  }


 

Most of the code is the basic plumbing used for Cascading apps. The portions that are specific to Cascading Pattern and PMML are the few lines involving the pmmlPlanner object.
![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/facebook.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/google_plus.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/linkedin.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/mail.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/facebook.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/google_plus.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/linkedin.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/mail.png)

