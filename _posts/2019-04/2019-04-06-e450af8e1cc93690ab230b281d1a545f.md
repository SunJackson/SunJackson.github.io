---
layout:     post
catalog: true
title:      Using svglite with web fonts by @ellis2013nz
subtitle:      转载自：http://feedproxy.google.com/~r/RBloggers/~3/mGu8gUtzndE/
date:      2019-04-06
author:      free range statistics - R
tags:
    - svg format
    - graphics devices
    - svglite
    - cairosvg
    - shapes
---





OK, no stats today, just fidgeting about with graphics devices and type faces. Caveat – the details of graphics formats and typefaces is not my area of real expertise, this blog post is me noting down things that I found useful and others might too. As always, corrections and comments are very welcome.

There are two main types of computer graphic formats:

- *vector* graphics, where the file is basically a set of instructions (start at x, draw a line at 30 degrees angle for y units, draw a circle of radius w centred at z, etc). Like something you generated with Inkscape or Adobe Illustrator.

- *raster* or *bitmap* graphics which are basically an array of numbers telling the computer which how to colour each pixel. Like a digital photograph.


Generally vector formats are far superior if you have the choice but large complex graphics (eg with millions of points, or maps with many fiddly bits) can be slow to render (and large to store). And until relatively recently many users’ web browsers could only show bitmap graphics. Internet Explorer 8 was the last high-use browser of this sort we had to worry about.

For my blog I work almost purely with Scalable Vector Graphic (SVG) format by choice, and PNG (a relatively efficient and high quality bitmap format) when I have to.

My graphics workflow for this blog is generally:

1. Write the graphic to a Scalable Vector Graphic (SVG)

1. Convert the SVGs to PNGs in batches using ImageMagick


I use the SVGs on the web pages that make up this blog; I need the PNG copies for posting on Twitter, Facebook and LinkedIn which don’t take SVGs, and also for some complex objects that would be too large as SVGs.

## A quick aside on anti-aliasing

To get in the groove of thinking about graphics I’m going to start with the concept of anti-aliasing. Here are three closeups of a straight line in a computer graphic, generated in R by three different graphics devices. From left to right these were generated by `CairoSVG()`, `CairoPNG()` and `png()`.

![](https://i2.wp.com/freerangestats.info/img/0150-compare-anti-aliasing.png?w=100%25)
![](https://i2.wp.com/freerangestats.info/img/0150-compare-anti-aliasing.png?w=100%25)


Aliasing (in graphics) refers to the jagged staircase-like bits of an image from approximating an ideal shape with crude collections of pixels. Anti-aliasing is basically the smoothing or blurring process to try to make the problem less obvious.

On a Windows machine (where I spend nearly all my working time), the `png()` device, no matter high a resolution you specify, will not use anti-aliasing and close ups of the image will reveal jagged bits like that in the right of the three options above. At the opposite end, a graphic that has been saved as SVG won’t have any aliasing at all coming from the file format itself; any jaggedness comes from the final rendering of the information in the file onto the screen (in the end, everything has to become pixels to get on the screen), not from how you generated the file.

The Cairo option in the middle has anti-aliasing taking place when the PNG file itself was generated. Files generated with `CairoPNG()` look much better than those from `png()`, but still can’t compete with the vector format even when the PNG is high resolution (eg 720 or more dots per inch).

Here’s the code that generated these examples

```
library(Cairo)
library(svglite)
library(frs)
library(clipr)

png("0150-antialias-none.png", 8 * 600, 4 * 600, res = 600)
plot(1:2, 1:2, type = "l", bty = "n", main = "No anti-alias png() device")
dev.off()

CairoPNG("0150-antialias-cairo.png", 8 * 600, 4 * 600, dpi = 600)
plot(1:2, 1:2, type = "l", bty = "n", main = "Anti-aliased CairoPNG device")
dev.off()

CairoSVG("0150-antialias-cairo.svg", 8, 4)
plot(1:2, 1:2, type = "l", bty = "n", main = "CairoSVG device")
dev.off()
```

> 
Potentially useful whimsical tip: once your awareness is raised about the need for anti-aliasing, you might become painfully aware of those unprofessional looking jagged bits in graphics. When working interactively in RStudio on Windows, all the graphics in your plot pane will look this way. If this hurts you like it hurts me, you can bring up a anti-aliased window with `CairoWin()` and plots will be rendered nicely on that window, and look much better than the crude default renditions. If you’re using two screens it’s also convenient for placing on your second screen.


## Different flavours of SVG

Until recently I’ve been generating my SVG files with `CairoSVG()`. However, I’ve gotten very disatisfied with how text is rendered by that format. It’s hard to put my finger on what is wrong, but it looks blurry, particularly when it’s about 10 point in size which of course is nearly all the time in statistical graphics. Sometimes the problem goes away when you zoom in, but that isn’t really the point.

I eventually solved this problem by moving to the excellent `svglite` package by Hadley Wickham, Lionel Henry, T Jake Luciani, Matthieu Decorde and Vaudor Lis. `svglite` creates smaller and faster SVGs and has a much better treatment of text in particular. But `svglite` alone wasn’t enough for the way I needed typefaces treated – I’ll get to that later.

To go into this further, here are three different SVG files, rendered in this web page as images, created by `Cairo::CairoSVG()`, `grDevices::svg()` and `svglite::svglite()`.

![](http://freerangestats.info/img/0150-cairo-svg.svg)
![](http://freerangestats.info/img/0150-cairo-svg.svg)
![](http://freerangestats.info/img/0150-svg.svg)
![](http://freerangestats.info/img/0150-svg.svg)
![](http://freerangestats.info/img/0150-svglite.svg)
![](http://freerangestats.info/img/0150-svglite.svg)


The first two approaches are very similar, but the `svglite` philosophy is quite different. `CairoSVG` and `svg` take text and turn it into many tiny shapes to draw; whereas `svglite` keeps the text as text in the SVG file and leaves it to the end user’s computer to render it. Zoom in close on any of those images above and the text will magnify nicely; but something about the relatively complicated approach of the first two makes them look a little blurred and complex when they’re looked at from a distance. This is the process of turning the text into individual shapes, interacting with the final rendering on the screen in some way that I don’t want to have to understand.

SVG files are just text files (in XML format) so we can look at the actual code (a huge advantage of SVG over other formats). Here’s the full text of the SVG generated by `CairoSVG`:

```
<?xml version="1.0" encoding="UTF-8"?>
 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="432pt" height="432pt" viewBox="0 0 432 432" version="1.1">


 overflow="visible" id="glyph0-0">
 style="stroke:none;" d="M 2.921875 0 L 2.921875 -26.128906 L 6.378906 -26.128906 L 6.378906 -15.398438 L 19.960938 -15.398438 L 19.960938 -26.128906 L 23.417969 -26.128906 L 23.417969 0 L 19.960938 0 L 19.960938 -12.316406 L 6.378906 -12.316406 L 6.378906 0 Z M 2.921875 0 "/>

```
