---
layout:     post
title:      Mastering high performance data algorithms I： Group By
subtitle:   转载自：http://wesmckinney.com/blog/mastering-high-performance-data-algorithms-i-group-by/
date:       2012-05-13
author:     Wes McKinney
header-img: img/background1.jpg
catalog: true
tags:
    - suppose
    - major
    - line profiling
    - dataset
    - carefully
---





** Sun 13 May 2012

 

I'm on my way back from [R/Finance 2012](http://www.rinfinance.com/). Those guys did a nice job of organizing the conference and was great to meet everyone there.

As part of [pandas](http://pandas.pydata.org/.) development, I have had to develop a suite of high performance data algorithms and implementation strategies which are the heart and soul of the library. I get asked a lot why pandas's [performance is much better than R](http://wesmckinney.com/blog?p=414) and other data manipulation tools. The reasons are two-fold: careful implementation (in Cython and and C, so minimizing the computational friction) and carefully-thought-out algorithms.

Here are some of the more important tools and ideas that I make use of on a day-to-day basis:

- **Hash tables** I use [klib](https://github.com/attractivechaos/klib). It's awesome and easy to use. I have this for critical algorithms like *unique*, *factorize* (unique + integer label assignment)

- **O(n) sort**, known in pandas as **groupsort**, on integers with known range. This is a variant of counting sort; if you have N integers with known range from 0 to K — 1, this can be sorted in O(N) time. Combining this tool with **factorize** (hash table-based), you can categorize and sort a large data set in linear time. Failure to understand these two algorithms will force you to pay O(N log N), dominating the runtime of your algorithm.

**Vectorized data movement and subsetting routines**: take, put, putmask, replace, etc.
Let me give you a prime example [from a commit yesterday](https://github.com/pydata/pandas/commit/e7af2b99634f5514554d10731f8b99dc070139cb) of me applying these ideas to great effect. Suppose I had a time series (or DataFrame containing time series) that I want to group by year, month, and day:

This is a small dataset, but imagine you have millions of observations and thousands or even millions of groups. How does that look algorithmically? I guarantee if you take a naive approach, you will crash and burn when the data increases in size. I know, because I did just that (take a look at the [vbenchmarks](http://pandas.pydata.org/pandas-docs/vbench/vb_groupby.html)). Laying down the infrastructure for doing a better job is not simple. Here are the steps for efficiently aggregating data like this:

- Factorize the group keys, computing integer label arrays (O(N) per key)

- Compute a "cartesian product number" or **group index** for each observation (since you could theoretically have K_1 * … * K_p groups observed, where K_i is the number of unique values in key i). This is again O(n) work.

- If the maximum number of groups is large, "compress" the group index by using the **factorize** algorithm on it again. imagine you have 1000 uniques per key and 3 keys; most likely you do not actually observe 1 billion key combinations but rather some much smaller number. O(n) work again

- For simple aggregations, like **mean**, go ahead and aggregate the data in one linear sweep without moving anything around.

Otherwise, for arbitrary user-defined aggregations, we have two options for chopping up the data set: sorting it (O(N) using groupsort!) or create index arrays indicating which observations belong to each group. The latter would be preferable in many cases to sorting a large data set (reordering the data, even though linear time, can be very costly).
I worked on speeding up the latter part of this last bullet point yesterday. The resulting code looked like this:

The details of `lib.indices_fast` aren't that interesting; it chops up `np.arange(len(group_index)).take(sorter)`, the sorted indirect indices, to produce the index dictionary. Running `%lprun` to get a line profiling on a large-ish data set:

You might say, well, this seems like a lot of work and maybe we should just zip the keys (forming an array of Python tuples) and do a dumb algorithm? The speed difference ends up being something like an order of magnitude or more faster by being careful in this way and working with indirect integer index arrays.

Anyway, in conclusion, it's these kinds of algorithms and ideas why pandas is perhaps the best-performing open-source data analysis toolkit for in memory data (I'm going to get to out-of-core data processing and "big data" eventually, just hang tight). It goes beyond language features and data structure internals (though this naturally also has a major impact, a lot of the things I do are easy to express in Python but would be very awkward or impossible to do in, say, R. Maybe I should write a whole article on this.); carefully thought-out algorithms are a major piece of the puzzle.
