---
layout:     post
title:      How-to： Build Re-usable Spark Programs using Spark Shell and Maven
subtitle:   转载自：http://blog.cloudera.com/blog/2015/03/how-to-build-re-usable-spark-programs-using-spark-shell-and-maven/
date:       2015-03-17
author:     Justin Kestelyn
header-img: img/background3.jpg
catalog: true
tags:
    - libraries
    - library
    - spark
    - files
    - maven
---

**Set up your own, or even a shared, environment for doing interactive analysis of time-series data.**

Although software engineering offers several methods and approaches to produce robust and reliable components, a more lightweight and flexible approach is required for data analysts—who do not build “products” per se but still need high-quality tools and components. Thus, recently, I tried to find a way to re-use existing libraries and datasets stored already in HDFS with [Apache Spark](https://spark.apache.org/). 

The use case involved information flow analysis based on time series and network data. In this use case, all measured data (primary data) is stored in time series buckets, which are Hadoop `SequenceFile`s with keys of type Text and values of type `VectorWritable` (from [Apache Mahout](http://mahout.apache.org/) 0.9). In my testing, I found the Spark shell to be a useful tool for doing interactive data analysis for this purpose, especially since the code involved can be modularized, re-used, and even shared.

In this post, you’ll learn how to set up your own, or even a shared, environment for doing interactive data analysis of time series within the Spark shell. Instead of developing an application, you will use Scala code snippets and third-party libraries to create reusable Spark modules.

## What is a Spark Module?

Using existing Java classes inside the Spark shell requires a solid deployment procedure and some dependency management. In addition to the Scala Simple Build tool ([sbt](http://www.scala-sbt.org/)), Apache Maven is really useful, too. 

![](http://blog.cloudera.com/wp-content/uploads/2015/03/spark-shell-f1.png)


**Figure 1:** For simple and reliable usage of Java classes and complete third-party libraries, we define a Spark Module as a self-contained artifact created by Maven. This module can easily be shared by multiple users. 

For this use case, you will need to create a single jar file containing all dependencies. In some cases, it is also really helpful to provide some Library wrapper tools. Such Helper classes should be well tested and documented. That way, you can achieve a kind of decoupling between data analysis and software development tasks.

Next, let’s go through the steps of creating this artifact.

## Set Up a New Maven Project

First, confirm you have Java 1.7 and Maven 3 installed. Create a new directory for your projects and use Maven to prepare a project directory. 







||$> mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DgroupId=org.etosha -DartifactId=infodynamics -Dfilter=org.apache.maven.archetypes:maven-archetype-quickstart|


Maven will ask:







||Choose archetype:  1: remote -> org.apache.maven.archetypes:maven-archetype-quickstart (An archetype which contains a sample Maven project.)  Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 1: Choose org.apache.maven.archetypes:maven-archetype-quickstart version:  1: 1.0-alpha-1  2: 1.0-alpha-2  3: 1.0-alpha-3  4: 1.0-alpha-4  5: 1.0  6: 1.1|

  1: remote -> org.apache.maven.archetypes:maven-archetype-quickstart (An archetype which contains a sample Maven project.)

  1: 1.0-alpha-1

  3: 1.0-alpha-3

  5: 1.0


Select (6) to work with Spark 1.1 locally or another number according to the settings for your cluster.

Now, add some dependencies to the automatically generated POM file.







||<dependency> <groupId>org.apache.mahout</groupId> <artifactId>mahout-math</artifactId> <version>0.9</version> <scope>provided</scope> <!--  use scope jar to ship it                                   as part of your module --></dependency> <dependency> <groupId>org.apache.mahout</groupId> <artifactId>mahout-core</artifactId> <version>0.9</version> <scope>provided</scope> <!--  use scope jar to ship it                                   as part of your module --></dependency>|

 <groupId>org.apache.mahout</groupId>

 <version>0.9</version>

                                   as part of your module -->

 

 <groupId>org.apache.mahout</groupId>

 <version>0.9</version>

                                   as part of your module -->


Mahout 0.9 libraries are also dependencies of Spark so you will need to add the scope “provided” to the dependency section—otherwise, Maven will load the library and all classes will be added to your final single jar file. (As our time-series buckets are `SequenceFile`s and contain objects of type `VectorWritable`, they require this version of Mahout.)

Another reason to package third-party libraries is for creating charts inside the Spark shell. If you have Gnuplot, it is really easy to plot results with the [Scalaplot](https://github.com/sameersingh/scalaplot) library. Just add this dependency definition to your pom.xml file and you are ready to plot:







||<dependency>    <groupId>org.sameersingh.scalaplot</groupId>    <artifactId>scalaplot</artifactId>    <version>0.0.3</version>  </dependency>|

    <groupId>org.sameersingh.scalaplot</groupId>

    <version>0.0.3</version>


 In this specific scenario the plan is to do some interactive time-series analysis within the Spark shell. First, you’ll want to evaluate the datasets and algorithms. You have to learn more about the domain before a custom application can be built and deployed. Finally, you can use Apache Oozie actions to execute the code but even in this case all third-party libraries have to be available as one artifact. 

It is worthwhile to invest some minutes in building such a single jar file—especially for projects that are more than just a hack—with all dependencies and to share this artifact among all the data scientists in your group.

But what about libraries that are not available in [Maven Central](http://search.maven.org/)–such as those on Sourceforge or [Google Code](https://code.google.com/)? 

## Download and Deploy a Third-Party-Library as Part of a Spark Module

You’ll need to prepare a location for all third-party libraries that are not available via Maven Central but are required in this particular project.







||


Now download the required artifacts, e.g. the JIDT library from Google Code, and decompress the zip file:







||$> wget http://information-dynamics-toolkit.googlecode.com/files/infodynamics-jar-0.1.4.zip $> unzip infodynamics-jar-0.1.4.zip|

 


Maven can deploy the artifact for you using the `mvn deploy:deploy-file` goal:







||$> mvn deploy:deploy-file \-Durl=file:///home/training/.m2/repository \ -Dfile=libs/infodynamics.jar \-DgroupId=org.etosha \-DartifactId=EXT.infodynamics \-Dpackaging=jar -Dversion=0.1.4|

-Durl=file:///home/training/.m2/repository \ -Dfile=libs/infodynamics.jar \

-DartifactId=EXT.infodynamics \


Now, you are ready to add this locally available library to the dependencies section of the POM file of the new Spark Module project:







||<dependency> <groupId>org.etosha</groupId> <artifactId>EXT.infodynamics</artifactId> <version>0.1.4</version></dependency>|

 <groupId>org.etosha</groupId>

 <version>0.1.4</version>


The next step is to add the Maven Assembly Plugin to the plugins-section in the `pom.xml` file. It manages the merge procedure for all available JAR files during the build.







|12345678910111213141516171819|<build><pluginManagement><plugins><plugin>  <artifactId>maven-assembly-plugin</artifactId>  <configuration>    <archive>      <manifest>      <mainClass>MyMAINClass</mainClass>      </manifest>    </archive>    <descriptorRefs>      <descriptorRef>jar-with-dependencies</descriptorRef>    </descriptorRefs>  </configuration></plugin>  </plugins>   </pluginManagement></build>|

2

4

6

8

10

12

14

16

18

<pluginManagement>

<plugin>

  <configuration>

      <manifest>

      </manifest>

    <descriptorRefs>

    </descriptorRefs>

</plugin>

   </pluginManagement>


Use the above `build` snippet and place it inside the project section.

Now you are ready to run the Maven build.







||$> mvn clean assembly:single|


The result will be a single JAR file with defined libraries built in. The file is located in the target directory. As a next step, run the Spark shell and test the settings.

## Run and Test the Single-JAR Spark-Module

To run Spark in interactive mode via Spark shell, just define a variable with the name `ADD_JARS`. If more than one jar file should be added, use a comma-separated list of paths. Now run the Spark shell with this command:







||$> ADD_JARS=target/infodynamics-SNAPHOT-1.0.jar spark-shell|


A fast validation can be done via the Web UI of the Spark shell application. It is available on port 4040, so open this URL http://localhost:4040/environment/ in a browser for validation.

[![](http://blog.cloudera.com/wp-content/uploads/2015/03/spark-shell-f2.png)
](http://blog.cloudera.com/wp-content/uploads/2015/03/spark-shell-f2.png)

**Figure 2:** Validation of Spark environment settings. Jar files that are available to the Spark nodes is shown in the marked field. One has to specify all additional paths in the property spark.jars.

Another test can now be done inside the Spark shell: just import some of the required Java classes, such as the `MatrixUtils`, from the third-party library. You just have to type:







||scala> import infodynamics.utils.MatrixUtils;|


At this point, you may well wonder how to save your Scala code that was entered into the Spark shell. After a successful interactive session, you can simply extract your input from the Spark shell history. The Spark shell logs all commands in a file called `.spark-history` in the user’s home directory. Within a Linux terminal, you run the tail command to conserve the latest commands before you go on.







||$> tail -n 5 .spark_history > mySession1.scala|


This command allows us to conserve the commands in a simple reusable script or as a base for further development in an IDE. Now, you can run this script file containing your Scala functions and custom code just by using the `:load` command. Inside the Spark shell you enter:







||scala> :load mySession1.scala|


And don’t forget to share your code! If you want to publish this module via Github, you can quickly follow the instructions [here](https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line).

Because visual investigation is an important time saver, let’s add the [scalaplot](https://github.com/sameersingh/scalaplot) library to this module. Now you can easily create some simple charts from the variables stored in the Spark shell. Because this post is not about RDDs and working with large datasets but rather about preparing the stage, follow the steps from the scalaplot documentation to plot a simple sine wave.







||scala> import org.sameersingh.scalaplot.Implicits._scala> val x = 0.0 until 2.0 * math.Pi by 0.1scala> output(GUI, plot(x ->(math.sin(_), math.cos(_))))|

scala> val x = 0.0 until 2.0 * math.Pi by 0.1


If your system shows a window with two waves now and no error messages appear, you are done for today. 

Congratulations, the Spark shell is now aware of your project libraries, including the plotting tools and the ”legacy” libraries containing the data types used in your SequenceFiles, all bundled in your first Spark module!

## Conclusion 

In this post, you learned how to manage and use external dependencies (especially to Java libraries) and project specific artifacts in the Spark shell. Now it is really easy to share and distribute the modules within your data analyst working group. 

*Mirko Kämpf is the lead instructor for the Cloudera Administrator Training for Apache Hadoop for Cloudera University.*
![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/facebook.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/google_plus.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/linkedin.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/32x32/mail.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/facebook.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/google_plus.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/linkedin.png)

![](http://blog.cloudera.com/wp-content/plugins/social-media-feather/synved-social/image/social/regular/64x64/mail.png)

