---
layout:     post
title:      The pandas escaped the zoo： Python's pandas vs. R's zoo benchmarks
subtitle:   转载自：http://wesmckinney.com/blog/the-pandas-escaped-the-zoo-pythons-pandas-vs-rs-zoo-benchmarks/
date:       2011-09-30
author:     Wes McKinney
header-img: img/background0.jpg
catalog: true
tags:
    - september
    - wm
    - fri
    - algorithm
    - unordered
---





** Fri 30 September 2011

 

> 
WM in 2015: Woefully out of date, but I preserve this post for posterity.


I tweeted that yesterday and figured it would be prudent to justify that with some code and real benchmarks. I'm really proud of pandas's performance after investing years of development building a tool that is both **easy-to-use** and **fast**. So here we go.

### The test case

The basic set-up is: you have two labeled vectors of different lengths and you add them together. The algorithm matches the labels and adds together the corresponding values. Simple, right?

### R/zoo benchmarks

Here's the R code:

In this benchmark, I get a timing of:

So, 1.15 seconds per iteration. There are a couple things to note here:

- The zoo package **pre-sorts** the objects by the index/label. As you will see below this makes a **big** performance difference as you can write a faster algorithm for ordered data.

- zoo returns an object whose index is the **intersection** of the indexes. I disagree with this design choice as I feel that it is discarding information. pandas returns the union (the "outer join", if you will) by default.


### Python benchmark

Here's the code doing basically the same thing, except using objects that are **not** pre-sorted by label:

And the timing:

Now, if I first sort the objects by index, a more specialized algorithm will be used:

Note that I'm also the fastest (that I know of) among Python libraries. Here's the above example using the [labeled array](http://pypi.python.org/pypi/la) package:

### The verdict

So in a apples-to-apples comparison, in this benchmark pandas is **26x** faster than zoo. Even in the completely unordered case (which is not apples-to-apples), it's 10x faster. I actually have a few tricks up my sleeve (as soon as I can find the time to implement them) to make the above operations even faster still =)
