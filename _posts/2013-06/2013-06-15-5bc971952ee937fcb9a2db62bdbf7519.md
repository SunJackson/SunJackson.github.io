---
layout:     post
title:      Numba vs. Cython： Take 2
subtitle:   转载自：http://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/
date:       2013-06-15
author:     Jake VanderPlas
header-img: img/background0.jpg
catalog: true
tags:
    - numba
    - array
    - cython
    - memory
    - autojit
---

Last summer I wrote a [post](http://jakevdp.github.io/blog/2012/08/24/numba-vs-cython)
comparing the performance of [Numba](http://numba.pydata.org/) and [Cython](http://cython.org/)
for optimizing array-based computation. Since posting, the page has received thousands of hits,
and resulted in a number of interesting discussions.
But in the meantime, the Numba package has come a long way both in its interface and its
performance.

Here I want to revisit those timing comparisons with a more recent Numba release, using the newer
and more convenient `autojit` syntax, and also add in a few additional benchmarks for
completeness. I've also written this post entirely within an IPython notebook, so it can be
easily downloaded and modified.

As before, I'll use a **pairwise distance** function. This will take an array representing
`M` points in `N` dimensions, and return the `M x M` matrix of pairwise distances.
This is a nice test function for a few reasons. First of all, it's a very clean and
well-defined test. Second of all, it illustrates the kind of array-based operation that
is common in statistics, datamining, and machine learning. Third, it is a function that
results in large memory consumption if the standard numpy broadcasting approach is used
(it requires a temporary array containing `M * M * N` elements), making it a good
candidate for an alternate approach.

We'll start by defining the array which we'll use for the benchmarks: one thousand points in
three dimensions.
