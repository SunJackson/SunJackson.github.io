---
layout:     post
title:      Optimizing Python in the Real World： NumPy, Numba, and the NUFFT
subtitle:   转载自：http://jakevdp.github.io/blog/2015/02/24/optimizing-python-with-numpy-and-numba/
date:       2015-02-24
author:     Jake VanderPlas
header-img: img/background2.jpg
catalog: true
tags:
    - transform
    - y_n
    - directly
    - gridding operation
    - uniform
---

The Fast Fourier Transform (FFT) is perhaps the most important and fundamental of modern numerical algorithms.
It provides a fast, $O[N\log N]$ method of computing the discrete Fourier transform:
$$
Y_k^\pm = \sum_{n=0}^{N-1} y_n e^{\pm i k n / N}
$$
You can read more about the FFT in [my previous post](https://jakevdp.github.io/blog/2013/08/28/understanding-the-fft) on the subject.

One important limitation of the FFT is that it requires that input data be evenly-spaced: that is, we can think of the values $y_n$ as samples of a function $y_n = y(x_n)$ where $x_n = x_0 + n\Delta x$ is a regular grid of points.
But what about when your grid is not uniform?
That is, what if you want to compute this result:
$$
Y_k^\pm = \sum_{j=1}^N y(x_j) e^{\pm i k x_j}
$$
where $y(x)$ is evaluated at an arbitrary set of points $x_j$?
In this case, the FFT is no longer directly applicable, and you're stuck using a much slower $O[N^2]$ direct summation.

Stuck, that is, until the NUFFT came along.

The NUFFT is an algorithm which converts the non-uniform transform into an approximate uniform transform, not with error-prone interpolation, but instead using a clever "gridding" operation motivated by the convolution theorem.
If you'd like to read about the algorithm in detail, the Courant Institute's [NUFFT page](http://www.cims.nyu.edu/cmcl/nufft/nufft.html) has a nice set of resources.

Below we'll take a look at implementing this algorithm in Python.
